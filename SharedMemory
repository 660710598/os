import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

// คลาสหลักของโปรแกรม
// - กำหนดจำนวน process
// - กำหนดขนาดพื้นที่ shared memory ต่อ process
// - กำหนดชื่อไฟล์สำหรับ shared memory
// - ใน main() จะสร้าง process และรันเป็น thread
public class DistributedProcessSharedMemorySimulation {

    public static final int NUM_PROCESSES = 3;   // จำนวน process ที่จะจำลอง
    public static final int REGION_SIZE = 128;   // ขนาด memory slot ต่อ process (byte)
    public static final String SHARED_FILE = "heartbeat_shared.dat"; // ไฟล์ shared memory

    public static void main(String[] args) {
        // สร้าง process จำลองตามจำนวน NUM_PROCESSES และรันพร้อมกัน
        for (int pid = 1; pid <= NUM_PROCESSES; pid++) {
            SimulatedProcess process = new SimulatedProcess(pid);
            Thread t = new Thread(process, "Process-" + pid);
            t.start();
        }
    }

    // คลาสแทน process จำลอง
    // - ภายในมี worker threads
    // - มี thread สำหรับส่ง heartbeat
    // - มี thread สำหรับฟัง heartbeat
    // - เก็บ membership (process อื่น ๆ ที่ alive)
    static class SimulatedProcess implements Runnable {
        private final int pid;  // รหัส process
        private static final int NUM_THREADS_PER_PROCESS = 3; // จำนวน worker thread ต่อ process
        private final MappedByteBuffer sharedBuffer; // memory map ร่วมกัน
        private final Set<Integer> membership; // รายชื่อ process อื่นที่เห็นว่า alive

        SimulatedProcess(int pid) {
            this.pid = pid;
            this.membership = ConcurrentHashMap.newKeySet();
            try {
                // เปิดไฟล์ shared memory
                RandomAccessFile raf = new RandomAccessFile(SHARED_FILE, "rw");
                long size = (long) NUM_PROCESSES * REGION_SIZE;

                // ถ้าไฟล์ยังไม่ใหญ่พอ ให้ขยายขนาด
                if (raf.length() < size) {
                    raf.setLength(size);
                }

                // map ไฟล์เข้าหน่วยความจำ
                FileChannel channel = raf.getChannel();
                this.sharedBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);
                channel.close();
                raf.close();
            } catch (IOException e) {
                throw new RuntimeException("ไม่สามารถ map shared memory ได้", e);
            }
        }

        @Override
        public void run() {
            System.out.println("[Process " + pid + "] starting");

            // thread สำหรับส่ง heartbeat
            Thread sender = new Thread(new HeartbeatSender(pid, sharedBuffer),
                                       "Process-" + pid + "-HeartbeatSender");

            // thread สำหรับฟัง heartbeat
            Thread listener = new Thread(new HeartbeatListener(pid, sharedBuffer,
                                       NUM_PROCESSES, membership),
                                       "Process-" + pid + "-HeartbeatListener");

            sender.start();
            listener.start();

            // worker threads ของ process
            List<Thread> workers = new ArrayList<>();
            for (int tid = 1; tid <= NUM_THREADS_PER_PROCESS; tid++) {
                SimulatedThread worker = new SimulatedThread(pid, tid);
                Thread wt = new Thread(worker, "Process-" + pid + "-Worker-" + tid);
                workers.add(wt);
                wt.start();
            }

            // รอ worker threads ทำงานเสร็จ
            for (Thread wt : workers) {
                try {
                    wt.join();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }

            // หยุด heartbeat threads
            sender.interrupt();
            listener.interrupt();
            try {
                sender.join();
                listener.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            // แสดง membership สุดท้าย
            System.out.println("[Process " + pid + "] terminating; members seen: " + membership);
        }
    }

    // Worker thread จำลองการทำงาน
    // - ทำงานวน 5 รอบ
    // - หน่วงเวลาสุ่ม เพื่อจำลองงานจริง
    static class SimulatedThread implements Runnable {
        private final int pid;
        private final int tid;

        SimulatedThread(int pid, int tid) {
            this.pid = pid;
            this.tid = tid;
        }

        @Override
        public void run() {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Process " + pid + " - Thread " + tid + " working (iteration " + i + ")");
                try {
                    Thread.sleep((long) (Math.random() * 500));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            System.out.println("Process " + pid + " - Thread " + tid + " finished");
        }
    }

    // คลาสสำหรับส่ง heartbeat
    // - เขียนข้อความ "PID:x alive" ลง shared memory ของตัวเองทุก 1 วินาที
    static class HeartbeatSender implements Runnable {
        private final int pid;
        private final MappedByteBuffer buffer;

        HeartbeatSender(int pid, MappedByteBuffer buffer) {
            this.pid = pid;
            this.buffer = buffer;
        }

        @Override
        public void run() {
            final int offset = (pid - 1) * REGION_SIZE; // offset ของ process นี้ใน shared memory
            final byte[] clearBytes = new byte[REGION_SIZE]; // สำหรับเคลียร์ข้อมูลเก่า

            while (!Thread.currentThread().isInterrupted()) {
                String message = "PID:" + pid + " alive"; // ข้อความ heartbeat
                byte[] data = message.getBytes(StandardCharsets.UTF_8);

                // เขียน heartbeat ลง shared memory
                synchronized (buffer) {
                    buffer.position(offset);
                    buffer.put(clearBytes, 0, clearBytes.length);
                    buffer.position(offset);
                    buffer.put(data, 0, Math.min(data.length, REGION_SIZE));
                }

                // log แสดงการเขียน heartbeat
                System.out.println("Process " + pid + " wrote heartbeat: " + message);

                try {
                    Thread.sleep(1000); // ส่งทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    // คลาสสำหรับฟัง heartbeat
    // - อ่านข้อมูลจาก slot ของ process อื่น
    // - ถ้าเจอข้อความ → process นั้น alive
    // - อัปเดต membership
    static class HeartbeatListener implements Runnable {
        private final int pid;
        private final MappedByteBuffer buffer;
        private final int numProcesses;
        private final Set<Integer> membership;

        HeartbeatListener(int pid, MappedByteBuffer buffer, int numProcesses,
                          Set<Integer> membership) {
            this.pid = pid;
            this.buffer = buffer;
            this.numProcesses = numProcesses;
            this.membership = membership;
        }

        @Override
        public void run() {
            final byte[] readBytes = new byte[REGION_SIZE];

            while (!Thread.currentThread().isInterrupted()) {
                membership.clear(); // เคลียร์ membership เดิม

                for (int otherPid = 1; otherPid <= numProcesses; otherPid++) {
                    if (otherPid == pid) continue; // ข้ามตัวเอง

                    int offset = (otherPid - 1) * REGION_SIZE;
                    String msg;

                    // อ่าน heartbeat จาก process อื่น
                    synchronized (buffer) {
                        buffer.position(offset);
                        buffer.get(readBytes, 0, REGION_SIZE);
                        msg = new String(readBytes, StandardCharsets.UTF_8).trim();
                    }

                    if (!msg.isEmpty()) {
                        membership.add(otherPid);
                        System.out.println("Process " + pid + " read heartbeat from PID " + otherPid + ": " + msg);
                    }
                }

                // แสดง membership ล่าสุด
                System.out.println("Process " + pid + " sees membership: " + membership);

                try {
                    Thread.sleep(1000); // เช็คทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
}
