import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

// คลาสหลักของโปรแกรม
// - กำหนดจำนวน process
// - กำหนดขนาดพื้นที่ shared memory ต่อ process
// - กำหนดชื่อไฟล์สำหรับ shared memory
// - ใน main() จะสร้าง process และรันเป็น thread
public class DistributedProcessSharedMemorySimulation {

    public static final int NUM_PROCESSES = 3;   // จำนวน process ที่จะจำลอง
    public static final int REGION_SIZE = 128;   // ขนาด memory slot ต่อ process (เป็น byte)
    public static final String SHARED_FILE = "heartbeat_shared.dat"; // ไฟล์ shared memory

    public static void main(String[] args) {
        // สร้าง process ตามจำนวน NUM_PROCESSES และรันพร้อมกัน
        for (int pid = 1; pid <= NUM_PROCESSES; pid++) {
            SimulatedProcess process = new SimulatedProcess(pid);
            Thread t = new Thread(process, "Process-" + pid);
            t.start();
        }
    }

    // คลาสแทน process จำลอง
    // - มี worker threads ภายใน
    // - มี thread สำหรับส่ง heartbeat
    // - มี thread สำหรับฟัง heartbeat
    // - เก็บ membership (process อื่น ๆ ที่ยัง alive)
    static class SimulatedProcess implements Runnable {
        private final int pid;  // รหัส process
        private static final int NUM_THREADS_PER_PROCESS = 3; // จำนวน worker thread ต่อ process
        private final MappedByteBuffer sharedBuffer; // memory map ร่วมกัน
        private final Set<Integer> membership; // รายชื่อ process อื่นที่เห็นว่า alive

        SimulatedProcess(int pid) {
            this.pid = pid;
            this.membership = ConcurrentHashMap.newKeySet();
            try {
                // เปิดไฟล์ shared memory สำหรับอ่าน/เขียน
                RandomAccessFile raf = new RandomAccessFile(SHARED_FILE, "rw");
                long size = (long) NUM_PROCESSES * REGION_SIZE;

                // ถ้าไฟล์เล็กเกินไป ให้ขยายขนาดไฟล์
                if (raf.length() < size) {
                    raf.setLength(size);
                }

                // map ไฟล์เข้าหน่วยความจำ
                FileChannel channel = raf.getChannel();
                this.sharedBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);
                channel.close();
                raf.close();
            } catch (IOException e) {
                throw new RuntimeException("ไม่สามารถ map shared memory ได้", e);
            }
        }

        @Override
        public void run() {
            System.out.println("[Process " + pid + "] เริ่มทำงาน");

            // สร้าง thread สำหรับส่ง heartbeat
            Thread sender = new Thread(new HeartbeatSender(pid, sharedBuffer),
                                       "Process-" + pid + "-HeartbeatSender");

            // สร้าง thread สำหรับฟัง heartbeat
            Thread listener = new Thread(new HeartbeatListener(pid, sharedBuffer,
                                       NUM_PROCESSES, membership),
                                       "Process-" + pid + "-HeartbeatListener");

            sender.start();
            listener.start();

            // สร้าง worker threads ภายใน process
            List<Thread> workers = new ArrayList<>();
            for (int tid = 1; tid <= NUM_THREADS_PER_PROCESS; tid++) {
                SimulatedThread worker = new SimulatedThread(pid, tid);
                Thread wt = new Thread(worker, "Process-" + pid + "-Worker-" + tid);
                workers.add(wt);
                wt.start();
            }

            // รอ worker ทุกตัวทำงานเสร็จ
            for (Thread wt : workers) {
                try {
                    wt.join();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }

            // หยุด heartbeat threads
            sender.interrupt();
            listener.interrupt();
            try {
                sender.join();
                listener.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            // แสดง membership สุดท้ายที่ process นี้เห็น
            System.out.println("[Process " + pid + "] จบการทำงาน; สมาชิกที่เห็น: " + membership);
        }
    }

    // Worker thread จำลองการทำงานภายใน process
    // - ทำงานวน loop 5 รอบ
    // - แสดงข้อความว่า thread กำลังทำงาน
    static class SimulatedThread implements Runnable {
        private final int pid;
        private final int tid;

        SimulatedThread(int pid, int tid) {
            this.pid = pid;
            this.tid = tid;
        }

        @Override
        public void run() {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Process " + pid + " - Thread " + tid
                        + " กำลังทำงาน (รอบ " + i + ")");
                try {
                    Thread.sleep((long) (Math.random() * 500)); // หน่วงเวลาแบบสุ่ม
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            System.out.println("Process " + pid + " - Thread " + tid + " เสร็จสิ้น");
        }
    }

    // คลาสสำหรับส่ง heartbeat
    // - เขียนข้อความ "PID:x alive" ลง shared memory ของตัวเองทุก 1 วินาที
    // - ใช้ตำแหน่ง (offset) ตาม PID เพื่อไม่ให้ชนกับ process อื่น
    static class HeartbeatSender implements Runnable {
        private final int pid;
        private final MappedByteBuffer buffer;

        HeartbeatSender(int pid, MappedByteBuffer buffer) {
            this.pid = pid;
            this.buffer = buffer;
        }

        @Override
        public void run() {
            final int offset = (pid - 1) * REGION_SIZE; // ตำแหน่ง memory ของ process นี้
            final byte[] clearBytes = new byte[REGION_SIZE]; // สำหรับล้างข้อมูลเก่า

            while (!Thread.currentThread().isInterrupted()) {
                String message = "PID:" + pid + " alive"; // ข้อความ heartbeat
                byte[] data = message.getBytes(StandardCharsets.UTF_8);

                // เขียน heartbeat ลง shared memory
                synchronized (buffer) {
                    buffer.position(offset);
                    buffer.put(clearBytes, 0, clearBytes.length); // ล้างค่าเก่า
                    buffer.position(offset);
                    buffer.put(data, 0, Math.min(data.length, REGION_SIZE));
                }

                // แสดง log การเขียน
                System.out.println("Process " + pid + " เขียน heartbeat: " + message);

                try {
                    Thread.sleep(1000); // ส่งทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    // คลาสสำหรับฟัง heartbeat
    // - อ่านข้อมูลจาก shared memory ของ process อื่น ๆ ทุก 1 วินาที
    // - ถ้าเจอข้อความ → แสดงว่า process นั้น alive
    // - อัปเดต membership ให้ทันสมัย
    static class HeartbeatListener implements Runnable {
        private final int pid;
        private final MappedByteBuffer buffer;
        private final int numProcesses;
        private final Set<Integer> membership;

        HeartbeatListener(int pid, MappedByteBuffer buffer, int numProcesses,
                          Set<Integer> membership) {
            this.pid = pid;
            this.buffer = buffer;
            this.numProcesses = numProcesses;
            this.membership = membership;
        }

        @Override
        public void run() {
            final byte[] readBytes = new byte[REGION_SIZE];

            while (!Thread.currentThread().isInterrupted()) {
                membership.clear(); // เคลียร์รายชื่อเก่าออกก่อน

                for (int otherPid = 1; otherPid <= numProcesses; otherPid++) {
                    if (otherPid == pid) continue; // ไม่อ่านของตัวเอง

                    int offset = (otherPid - 1) * REGION_SIZE;
                    String msg;

                    // อ่านจาก slot ของ process อื่น
                    synchronized (buffer) {
                        buffer.position(offset);
                        buffer.get(readBytes, 0, REGION_SIZE);
                        msg = new String(readBytes, StandardCharsets.UTF_8).trim();
                    }

                    // ถ้ามีข้อความ แปลว่า process นั้นยัง alive
                    if (!msg.isEmpty()) {
                        membership.add(otherPid);
                        System.out.println("Process " + pid + " อ่าน heartbeat จาก PID "
                                + otherPid + ": " + msg);
                    }
                }

                // แสดง membership ที่เห็นในรอบนี้
                System.out.println("Process " + pid + " เห็นสมาชิก: " + membership);

                try {
                    Thread.sleep(1000); // เช็คทุก 1 วินาที
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
}
